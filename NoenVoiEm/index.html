<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NoenVoiEm</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000000;
      font-family: 'Times New Roman', serif;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    /* UI Overlay - Minimalist */
    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 40px;
      box-sizing: border-box;
      /* Remove transition here as we don't hide the whole layer anymore */
    }

    /* When hidden class i s applied to specific elements */
    .ui-hidden {
      opacity: 0;
      pointer-events: none !important;
    }

    /* Loading */
    #loader {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.8s ease-out;
    }

    .loader-text {
      color: #d4af37;
      font-size: 14px;
      letter-spacing: 4px;
      margin-top: 20px;
      text-transform: uppercase;
      font-weight: 100;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 1px solid rgba(212, 175, 55, 0.2);
      border-top: 1px solid #d4af37;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    /* Typography - Centerpiece */
    h1 {
      color: #fceea7;
      font-size: 56px;
      margin: 0;
      font-weight: 400;
      letter-spacing: 6px;
      text-shadow: 0 0 50px rgba(252, 238, 167, 0.6);
      background: linear-gradient(to bottom, #fff, #eebb66);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-family: 'Cinzel', 'Times New Roman', serif;
      opacity: 0.9;
      transition: opacity 0.5s ease;
      /* Ensure smooth transitions if needed */
    }

    /* Upload Button - Restored & Elegant */
    .upload-wrapper {
      margin-top: 20px;
      pointer-events: auto;
      text-align: center;
      transition: opacity 0.5s ease;
      /* Add transition for smooth hiding */
    }

    .upload-btn {
      background: rgba(20, 20, 20, 0.6);
      border: 1px solid rgba(212, 175, 55, 0.4);
      color: #d4af37;
      padding: 10px 25px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 3px;
      font-size: 10px;
      transition: all 0.4s;
      display: inline-block;
      backdrop-filter: blur(5px);
    }

    .upload-btn:hover {
      background: #d4af37;
      color: #000;
      box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
    }

    .hint-text {
      color: rgba(212, 175, 55, 0.5);
      font-size: 9px;
      margin-top: 8px;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    #file-input {
      display: none;
    }

    /* Webcam feedback */
    #webcam-wrapper {
      position: absolute;
      bottom: 40px;
      left: 40px;
      z-index: 9999;
      display: block;
      width: 240px;
      height: 160px;
      border: 1px solid rgba(212, 175, 55, 0.5);
      overflow: hidden;
      opacity: 1;
      /* Hidden by default but functional */
      pointer-events: none;
    }
  </style>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
  </style>

  <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>

<body>

  <audio id="bg-music" loop>
    <source src="background.MP3" type="audio/mpeg">
  </audio>

  <div id="loader">
    <div class="spinner"></div>
    <div class="loader-text">Loading Holiday Magic</div>
  </div>

  <div id="canvas-container"></div>

  <div id="ui-layer">
    <h1>Merry Christmas</h1>

    <div class="upload-wrapper">
      <label class="upload-btn">
        Add Memories
        <input type="file" id="file-input" multiple accept="image/*">
      </label>
      <div class="hint-text">Press 'H' to Hide Controls</div>
    </div>
  </div>

  <!-- Webcam hidden structure -->
  <div id="webcam-wrapper">
    <video id="webcam" autoplay playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
    <canvas id="webcam-preview" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // --- CONFIGURATION ---
    const CONFIG = {
      colors: {
        bg: 0x000000,
        champagneGold: 0xffd966,
        deepGreen: 0x03180a,
        accentRed: 0x990000,
      },
      particles: {
        count: 2500,
        dustCount: 2500,
        treeHeight: 30,
        treeRadius: 8
      },
      camera: {
        z: 60
      }
    };

    const INITIAL_IMAGES = [
      './pic1.jpg',
      './pic2.jpg',
      './pic.jpg',
      './pic4.jpg',
      './pic5.jpg',
      './pic6.jpg',
      './pic7.jpg',
      './pic8.jpg',
      './pic9.jpg',
      './pic10.jpg',
      './pic11.jpg',
      './pic12.jpg',
      './pic13.jpg',
      './pic14.jpg',
      './pic15.jpg',
      './pic16.jpg',
      './pic17.jpg',
      './pic18.jpg',
      './pic19.jpg',
      './pic20.jpg',
      './pic21.jpg',
      './pic22.jpg',
      './pic23.jpg',
      './pic24.jpg',
      './pic25.jpg',
    ];

    const STATE = {
      mode: 'TREE',
      focusIndex: -1,
      focusTarget: null,
      hand: { detected: false, x: 0, y: 0 },
      rotation: { x: 0, y: 0 }
    };

    let scene, camera, renderer, composer;
    let mainGroup;
    let clock = new THREE.Clock();
    let particleSystem = [];
    let photoMeshGroup = new THREE.Group();
    let handLandmarker, video, webcamCanvas, webcamCtx;
    let caneTexture;
    // 拖拽旋转状态（用于滑动旋转粒子）
    let dragState = { vx: 0, vy: 0, isDown: false, lastX: 0, lastY: 0 };

    function loadInitialImages() {
      const loader = new THREE.TextureLoader();

      INITIAL_IMAGES.forEach(path => {
        loader.load(
          path,
          (texture) => {
            // Setup color space for correct rendering
            texture.colorSpace = THREE.SRGBColorSpace;
            // Add to the tree using your existing logic
            addPhotoToScene(texture);
          },
          undefined, // onProgress callback (not needed)
          (err) => {
            console.error(`Error loading image at path: ${path}`, err);
          }
        );
      });
    }

    async function init() {
      initThree();
      setupEnvironment();
      setupLights();
      createTextures();
      createParticles();
      createDust();
      loadInitialImages();
      createDefaultPhotos(); //"Merry Christmas" text card
      setupPostProcessing();
      setupEvents();
      await initMediaPipe();

      const loader = document.getElementById('loader');
      loader.style.opacity = 0;
      setTimeout(() => loader.remove(), 800);

      animate();
    }

    function initThree() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.colors.bg);
      scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.01);

      camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, CONFIG.camera.z);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.toneMapping = THREE.ReinhardToneMapping;
      renderer.toneMappingExposure = 1.2; // 降低曝光使整体更暗
      container.appendChild(renderer.domElement);

      mainGroup = new THREE.Group();
      scene.add(mainGroup);
    }

    function setupEnvironment() {
      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
    }

    function setupLights() {
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);

      const innerLight = new THREE.PointLight(0xffaa00, 2, 20);
      innerLight.position.set(0, 5, 0);
      mainGroup.add(innerLight);

      const spotGold = new THREE.SpotLight(0xffcc66, 1200);
      spotGold.position.set(30, 40, 40);
      spotGold.angle = 0.5;
      spotGold.penumbra = 0.5;
      scene.add(spotGold);

      const spotBlue = new THREE.SpotLight(0x6688ff, 600);
      spotBlue.position.set(-30, 20, -30);
      scene.add(spotBlue);

      const fill = new THREE.DirectionalLight(0xffeebb, 0.8);
      fill.position.set(0, 0, 50);
      scene.add(fill);
    }

    function setupPostProcessing() {
      const renderScene = new RenderPass(scene, camera);
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
      bloomPass.threshold = 0.7;
      bloomPass.strength = 0.45;
      bloomPass.radius = 0.4;

      composer = new EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);
    }

    function createTextures() {
      const canvas = document.createElement('canvas');
      canvas.width = 128; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, 128, 128);
      ctx.fillStyle = '#880000';
      ctx.beginPath();
      for (let i = -128; i < 256; i += 32) {
        ctx.moveTo(i, 0); ctx.lineTo(i + 32, 128); ctx.lineTo(i + 16, 128); ctx.lineTo(i - 16, 0);
      }
      ctx.fill();
      caneTexture = new THREE.CanvasTexture(canvas);
      caneTexture.wrapS = THREE.RepeatWrapping;
      caneTexture.wrapT = THREE.RepeatWrapping;
      caneTexture.repeat.set(3, 3);
    }

    class Particle {
      constructor(mesh, type, isDust = false) {
        this.mesh = mesh;
        this.type = type;
        this.isDust = isDust;

        this.posTree = new THREE.Vector3();
        this.posScatter = new THREE.Vector3();
        this.baseScale = mesh.scale.x;

        // Individual Spin Speed
        // Photos spin slower to be readable
        const speedMult = (type === 'PHOTO') ? 0.3 : 2.0;

        this.spinSpeed = new THREE.Vector3(
          (Math.random() - 0.5) * speedMult,
          (Math.random() - 0.5) * speedMult,
          (Math.random() - 0.5) * speedMult
        );

        this.calculatePositions();
      }

      calculatePositions() {
        // TREE: Tight Spiral
        const h = CONFIG.particles.treeHeight;
        const halfH = h / 2;
        let t = Math.random();
        t = Math.pow(t, 0.8);
        const y = (t * h) - halfH;
        let rMax = CONFIG.particles.treeRadius * (1.0 - t);
        if (rMax < 0.5) rMax = 0.5;
        const angle = t * 50 * Math.PI + Math.random() * Math.PI;
        const r = rMax * (0.8 + Math.random() * 0.4);
        this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);

        // SCATTER: 3D Sphere
        let rScatter = this.isDust ? (12 + Math.random() * 20) : (8 + Math.random() * 12);
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        this.posScatter.set(
          rScatter * Math.sin(phi) * Math.cos(theta),
          rScatter * Math.sin(phi) * Math.sin(theta),
          rScatter * Math.cos(phi)
        );
      }

      update(dt, mode, focusTargetMesh) {
        let target = this.posTree;

        if (mode === 'SCATTER') target = this.posScatter;
        else if (mode === 'FOCUS') {
          if (this.mesh === focusTargetMesh) {
            const desiredWorldPos = new THREE.Vector3(0, 2, 35);
            const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
            target = desiredWorldPos.applyMatrix4(invMatrix);
          } else {
            target = this.posScatter;
          }
        }

        // Movement Easing
        const lerpSpeed = (mode === 'FOCUS' && this.mesh === focusTargetMesh) ? 5.0 : 1.2;
        this.mesh.position.lerp(target, lerpSpeed * dt);

        // Rotation Logic - CRITICAL: Ensure spin happens in Scatter
        if (mode === 'SCATTER') {
          this.mesh.rotation.x += this.spinSpeed.x * dt;
          this.mesh.rotation.y += this.spinSpeed.y * dt;
          this.mesh.rotation.z += this.spinSpeed.z * dt; // Added Z for more natural tumble
        } else if (mode === 'TREE') {
          // Reset rotations slowly
          this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt);
          this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt);
          this.mesh.rotation.y += 0.5 * dt;
        }

        if (mode === 'FOCUS' && this.mesh === focusTargetMesh) {
          this.mesh.lookAt(camera.position);
        }

        // Scale Logic
        let s = this.baseScale;
        if (this.isDust) {
          s = this.baseScale * (0.8 + 0.4 * Math.sin(clock.elapsedTime * 4 + this.mesh.id));
          if (mode === 'TREE') s = 0;
        } else if (mode === 'SCATTER' && this.type === 'PHOTO') {
          // Large preview size in scatter
          s = this.baseScale * 2.5;
        } else if (mode === 'FOCUS') {
          if (this.mesh === focusTargetMesh) s = 4.5;
          else s = this.baseScale * 0.8;
        }

        this.mesh.scale.lerp(new THREE.Vector3(s, s, s), 4 * dt);
      }
    }

    // --- CREATION ---
    function createParticles() {
      const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32);
      const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55);
      const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.3, 0),
        new THREE.Vector3(0.1, 0.5, 0), new THREE.Vector3(0.3, 0.4, 0)
      ]);
      const candyGeo = new THREE.TubeGeometry(curve, 16, 0.08, 8, false);

      const goldMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.champagneGold,
        metalness: 1.0, roughness: 0.1,
        envMapIntensity: 2.0,
        emissive: 0x443300,
        emissiveIntensity: 0.3
      });

      const greenMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.deepGreen,
        metalness: 0.2, roughness: 0.8,
        emissive: 0x002200,
        emissiveIntensity: 0.2
      });

      const redMat = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.accentRed,
        metalness: 0.3, roughness: 0.2, clearcoat: 1.0,
        emissive: 0x330000
      });

      const candyMat = new THREE.MeshStandardMaterial({ map: caneTexture, roughness: 0.4 });

      for (let i = 0; i < CONFIG.particles.count; i++) {
        const rand = Math.random();
        let mesh, type;

        if (rand < 0.40) {
          mesh = new THREE.Mesh(boxGeo, greenMat);
          type = 'BOX';
        } else if (rand < 0.70) {
          mesh = new THREE.Mesh(boxGeo, goldMat);
          type = 'GOLD_BOX';
        } else if (rand < 0.92) {
          mesh = new THREE.Mesh(sphereGeo, goldMat);
          type = 'GOLD_SPHERE';
        } else if (rand < 0.97) {
          mesh = new THREE.Mesh(sphereGeo, redMat);
          type = 'RED';
        } else {
          mesh = new THREE.Mesh(candyGeo, candyMat);
          type = 'CANE';
        }

        const s = 0.4 + Math.random() * 0.5;
        mesh.scale.set(s, s, s);
        mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);

        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, type, false));
      }

      // 创建竖直的五角星作为顶部装饰（Shape + ExtrudeGeometry）
      (function createStarTop() {
        const outerR = 1.2;
        const innerR = outerR * 0.45;
        const pts = [];
        for (let i = 0; i < 10; i++) {
          const angle = (i * Math.PI) / 5 - Math.PI / 2; // 使尖端朝上
          const r = (i % 2 === 0) ? outerR : innerR;
          pts.push(new THREE.Vector2(Math.cos(angle) * r, Math.sin(angle) * r));
        }
        const shape = new THREE.Shape(pts);
        const extrudeSettings = {
          depth: 0.4,
          bevelEnabled: true,
          bevelThickness: 0.06,
          bevelSize: 0.06,
          bevelSegments: 2
        };
        const starGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        starGeo.center();
        const starMat = new THREE.MeshStandardMaterial({
          color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 1.0,
          metalness: 1.0, roughness: 0
        });
        const star = new THREE.Mesh(starGeo, starMat);
        // 确保星尖朝上，ExtrudeGeometry 在 XY 平面拉伸 Z 轴，Y 轴为上
        star.position.set(0, CONFIG.particles.treeHeight / 2 + outerR * 0.9, 0);
        mainGroup.add(star);
      })();

      mainGroup.add(photoMeshGroup);
    }

    function createDust() {
      const geo = new THREE.TetrahedronGeometry(0.08, 0);
      const mat = new THREE.MeshBasicMaterial({ color: 0xffeebb, transparent: true, opacity: 0.8 });

      for (let i = 0; i < CONFIG.particles.dustCount; i++) {
        const mesh = new THREE.Mesh(geo, mat);
        mesh.scale.setScalar(0.5 + Math.random());
        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, 'DUST', true));
      }
    }

    function createDefaultPhotos() {
      const canvas = document.createElement('canvas');
      canvas.width = 512; canvas.height = 512;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, 512, 512);
      ctx.strokeStyle = '#eebb66'; ctx.lineWidth = 15; ctx.strokeRect(20, 20, 472, 472);
      ctx.font = '500 60px Times New Roman'; ctx.fillStyle = '#eebb66';
      ctx.textAlign = 'center';
      ctx.fillText("MERRY", 256, 230);
      ctx.fillText("CHRISTMAS", 256, 300);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      addPhotoToScene(tex);
    }

    function addPhotoToScene(texture) {
      const img = texture.image;
      const iw = img.width;
      const ih = img.height;

      // 固定高度
      const photoH = 1.2;
      const frameH = 1.4;

      // 宽度按比例
      const ratio = iw / ih;
      const photoW = photoH * ratio;
      const frameW = frameH * ratio;

      // --- 相框（适配比例） ---
      const frameGeo = new THREE.BoxGeometry(frameW, frameH, 0.05);
      const frameMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.champagneGold,
        metalness: 1.0,
        roughness: 0.1
      });
      const frame = new THREE.Mesh(frameGeo, frameMat);

      // --- 照片（适配比例） ---
      const photoGeo = new THREE.PlaneGeometry(photoW, photoH);
      const photoMat = new THREE.MeshBasicMaterial({
        map: texture,
        toneMapped: false
      });
      const photo = new THREE.Mesh(photoGeo, photoMat);
      photo.position.z = 0.04;

      // --- 分组 ---
      const group = new THREE.Group();
      group.add(frame);
      group.add(photo);

      const s = 0.8;
      group.scale.set(s, s, s);

      photoMeshGroup.add(group);
      particleSystem.push(new Particle(group, 'PHOTO', false));
    }

    function handleImageUpload(e) {
      const files = e.target.files;
      if (!files.length) return;
      Array.from(files).forEach(f => {
        const reader = new FileReader();
        reader.onload = (ev) => {
          new THREE.TextureLoader().load(ev.target.result, (t) => {
            t.colorSpace = THREE.SRGBColorSpace;
            addPhotoToScene(t);
          });
        }
        reader.readAsDataURL(f);
      });
    }

    // --- MEDIAPIPE ---
    async function initMediaPipe() {
      video = document.getElementById('webcam');
      webcamCanvas = document.getElementById('webcam-preview');
      webcamCtx = webcamCanvas.getContext('2d');
      webcamCanvas.width = 640; webcamCanvas.height = 480;

      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
      );
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
          delegate: "GPU"
        },
        runningMode: "VIDEO",
        numHands: 1
      });

      let useMockInput = false;
      if (navigator.mediaDevices?.getUserMedia) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: true });
          video.srcObject = stream;
          video.addEventListener("loadeddata", predictWebcam);
        } catch (err) {
          console.warn('无法访问摄像头，启用鼠标回退输入：', err && err.message);
          useMockInput = true;
          enableMouseHandControls();
          // 仍然启动预测循环，但不会调用 Mediapipe 的 detectForVideo
          requestAnimationFrame(predictWebcam);
        }
      } else {
        console.warn('浏览器不支持 getUserMedia，启用鼠标回退输入');
        useMockInput = true;
        enableMouseHandControls();
        requestAnimationFrame(predictWebcam);
      }
    }

    let lastVideoTime = -1;
    async function predictWebcam() {
      // 如果视频可用且 MediaPipe 已初始化，使用 detectForVideo
      try {
        if (video && typeof video.currentTime !== 'undefined' && video.readyState >= 2 && handLandmarker) {
          if (video.currentTime !== lastVideoTime) {
            lastVideoTime = video.currentTime;
            const result = handLandmarker.detectForVideo(video, performance.now());
            processGestures(result);
          }
        }
      } catch (err) {
        // 如果检测失败，不中断主循环
        console.debug('手部检测出错（可能使用回退输入）:', err && err.message);
      }
      requestAnimationFrame(predictWebcam);
    }

    // 鼠标/触摸回退输入：在没有摄像头时使用，映射到 STATE.hand
    function enableMouseHandControls() {
      const el = renderer ? renderer.domElement : window;
      let isDown = false;

      function updateFromEvent(e) {
        const rect = el.getBoundingClientRect ? el.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
        const x = ((e.clientX - rect.left) / rect.width - 0.5) * 2;
        const y = ((e.clientY - rect.top) / rect.height - 0.5) * 2;
        STATE.hand.detected = true;
        STATE.hand.x = x;
        STATE.hand.y = y;
      }

      function onPointerMove(e) {
        updateFromEvent(e);
      }
      function onPointerDown(e) {
        isDown = true;
        updateFromEvent(e);
        // 模拟捏合（FOCUS）行为：切换到 FOCUS 并随机选择一个照片作为焦点
        STATE.mode = 'FOCUS';
        const photos = particleSystem.filter(p => p.type === 'PHOTO');
        if (photos.length) STATE.focusTarget = photos[Math.floor(Math.random() * photos.length)].mesh;
      }
      function onPointerUp(e) {
        isDown = false;
        STATE.hand.detected = false;
        // 恢复到 TREE 模式
        STATE.mode = 'TREE';
        STATE.focusTarget = null;
      }

      el.addEventListener('pointermove', onPointerMove);
      el.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('pointerup', onPointerUp);

      // 清理函数（如果需要在未来移除）
      enableMouseHandControls._cleanup = () => {
        el.removeEventListener('pointermove', onPointerMove);
        el.removeEventListener('pointerdown', onPointerDown);
        window.removeEventListener('pointerup', onPointerUp);
      };
    }

    function processGestures(result) {
      if (result.landmarks && result.landmarks.length > 0) {
        STATE.hand.detected = true;
        const lm = result.landmarks[0];
        STATE.hand.x = (lm[9].x - 0.5) * 2;
        STATE.hand.y = (lm[9].y - 0.5) * 2;

        const thumb = lm[4]; const index = lm[8]; const wrist = lm[0];
        const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
        const tips = [lm[8], lm[12], lm[16], lm[20]];
        let avgDist = 0;
        tips.forEach(t => avgDist += Math.hypot(t.x - wrist.x, t.y - wrist.y));
        avgDist /= 4;

        if (pinchDist < 0.075) {
          if (STATE.mode !== 'FOCUS') {
            STATE.mode = 'FOCUS';
            const photos = particleSystem.filter(p => p.type === 'PHOTO');
            if (photos.length) STATE.focusTarget = photos[Math.floor(Math.random() * photos.length)].mesh;
          }
        } else if (avgDist < 0.35) {
          STATE.mode = 'TREE';
          STATE.focusTarget = null;
        } else if (avgDist > 0.45) {
          STATE.mode = 'SCATTER';
          STATE.focusTarget = null;
        }
      } else {
        STATE.hand.detected = false;
      }
    }

    function setupEvents() {
    
      
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });
      document.getElementById('file-input').addEventListener('change', handleImageUpload);

      // Toggle UI logic - ONLY hide controls, keep title
      // --- KEYBOARD CONTROLS (H, P, Space) ---
      window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        const code = e.code;

        // 1. Press 'H' to Hide/Show Controls
        if (key === 'h') {
          const controls = document.querySelector('.upload-wrapper');
          if (controls) controls.classList.toggle('ui-hidden');
        }

        // 2. Press 'P' to Toggle Music
        if (key === 'p') {
          const music = document.getElementById('bg-music');
          if (music) {
            if (music.volume === 1) music.volume = 1.0; // Set volume if needed
            if (music.paused) {
              music.play().catch(err => console.log("Click screen first!"));
            } else {
              music.pause();
            }
          }
        }

        // 3. Press 'SPACE' to Go to Heart Page
        if (code === 'Space') {
          e.preventDefault(); // Stop the page from scrolling down
          window.location.href = 'trai_tim.html';
        }
      });

      // 支持滑动/拖拽旋转：在 renderer.domElement 上监听 pointer 事件
      const el = renderer.domElement;
      function onDragStart(e) {
        dragState.isDown = true;
        dragState.lastX = e.clientX;
        dragState.lastY = e.clientY;
        dragState.vx = 0; dragState.vy = 0;
      }
      function onDragMove(e) {
        if (!dragState.isDown) return;
        const dx = e.clientX - dragState.lastX;
        const dy = e.clientY - dragState.lastY;
        dragState.lastX = e.clientX; dragState.lastY = e.clientY;

        // 将屏幕位移转换为旋转角度（经验系数）
        const angY = -dx / window.innerWidth * Math.PI; // 水平滑动 -> 绕 Y 轴旋转
        const angX = -dy / window.innerHeight * Math.PI * 0.5; // 垂直滑动 -> 绕 X 轴旋转（有限制）

        // 立即应用少量旋转用于响应
        STATE.rotation.y += angY;
        STATE.rotation.x = Math.max(Math.min(STATE.rotation.x + angX, Math.PI * 0.4), -Math.PI * 0.4);

        // 设置惯性速度，用于松手后继续缓慢旋转
        // 放大因子以便明显感知惯性
        dragState.vy = angY * 4.0;
        dragState.vx = angX * 3.5;
      }
      function onDragEnd(e) {
        dragState.isDown = false;
      }

      el.addEventListener('pointerdown', onDragStart);
      window.addEventListener('pointermove', onDragMove);
      window.addEventListener('pointerup', onDragEnd);

      // 清理引用（若需要）
      setupEvents._cleanup = () => {
        el.removeEventListener('pointerdown', onDragStart);
        window.removeEventListener('pointermove', onDragMove);
        window.removeEventListener('pointerup', onDragEnd);
      };
    }

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      // Rotation Logic
      if (STATE.mode === 'SCATTER' && STATE.hand.detected) {
        const targetRotY = STATE.hand.x * Math.PI * 0.9;
        const targetRotX = STATE.hand.y * Math.PI * 0.25;
        STATE.rotation.y += (targetRotY - STATE.rotation.y) * 3.0 * dt;
        STATE.rotation.x += (targetRotX - STATE.rotation.x) * 3.0 * dt;
      } else {
        if (STATE.mode === 'TREE') {
          STATE.rotation.y += 0.3 * dt;
          STATE.rotation.x += (0 - STATE.rotation.x) * 2.0 * dt;
        } else {
          STATE.rotation.y += 0.1 * dt;
        }
      }

      // 将拖拽惯性应用到旋转上（无论当前模式），并衰减惯性
      STATE.rotation.y += dragState.vy * dt;
      STATE.rotation.x += dragState.vx * dt;
      // 衰减速度
      const decay = Math.exp(-6.0 * dt);
      dragState.vy *= decay;
      dragState.vx *= decay;

      mainGroup.rotation.y = STATE.rotation.y;
      mainGroup.rotation.x = STATE.rotation.x;

      particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));
      composer.render();
    }

    init();
  </script>
</body>

</html>